#!/usr/bin/env ruby

# Script for generating static pages, providing an overview of the
# merge queues for the repositories managed by the associated
# test_pull_requests configuration file

require 'erb'
require 'getoptlong'
require 'json'

DEFAULT_MERGE_QUEUE_PROPERTIES_LOCATION = "~/.test_pull_requests.json"
DEFAULT_CONFIG_FILE = "~/.merge_queue_for_test_pull_requests.json"

def usage
  puts <<USAGE
Usage: merge_queue_overview [--help] [--config <path_to_config>]

This will process all the merge queue data generated by the
test_pull_requests run specified in the config file

Options:
-h|--help
    Show Usage info
-c|--config <path_to_config>
    Path to config file. Defaults to #{DEFAULT_CONFIG_FILE}
-m|--merge_queue_records <path_to_merge_queue_records>
    Use this file to source merge queue data instead of standard path
    derived from config path (TESTING)
USAGE
  exit 255
end

opts = GetoptLong.new(
["--help",   "-h",              GetoptLong::NO_ARGUMENT],
["--config", "-c",              GetoptLong::REQUIRED_ARGUMENT],
["--merge_queue_records", "-m", GetoptLong::REQUIRED_ARGUMENT]
)

args = {}
begin
  opts.each{ |k,v| args[k[2..-1].intern]=v }
rescue GetoptLong::Error
  usage
end

if args[:help]
  usage
end

config_location = args[:config]
merge_queue_records = args[:merge_queue_records]

CONFIG_LOCATION = config_location || DEFAULT_CONFIG_FILE
config = if File.exists? CONFIG_LOCATION
  JSON.parse(IO.read(CONFIG_LOCATION))
else
  $stderr.puts "Couldn't load config file #{CONFIG_LOCATION}"
  exit 255
end

PROPERTIES_LOCATION = config['merge_queue_properties_location'] || DEFAULT_MERGE_QUEUE_PROPERTIES_LOCATION
MERGE_QUEUE_RECORD_FILENAME = PROPERTIES_LOCATION[/[^\w]+\.(.+\.json)/, 1]
MERGE_QUEUE_RECORD = File.expand_path(merge_queue_records || "~/merge_queue_records/#{MERGE_QUEUE_RECORD_FILENAME}")

def write_merge_queue_overview(queue_name, config, queue_records, erb)
  # Make the merge queue name nice and filesystem/url-safe
  merge_queue_output_filename = queue_name.downcase.gsub(/[^\w\s_-]+/, '').gsub(/\s+/, '_')
  output_filespec = File.expand_path("#{config['output_directory']}/#{merge_queue_output_filename}.html")
  IO.write(output_filespec, erb.result(binding), {:mode => 'w'})
end

queue_name = config['merge_queue_name']
queue_records_from_file = if File.exists? MERGE_QUEUE_RECORD
  JSON.parse(IO.read(MERGE_QUEUE_RECORD))
else
  $stderr.puts "Couldn't load merge queue records file #{MERGE_QUEUE_RECORD}"
  exit 255
end

logo_url = config['logo_url']

erb = ERB.new(File.open(File.expand_path("#{config['template_directory']}/merge_queue_overview.erb"), "rb").read)

if config['repo_groups']
  config['repo_groups'].each do |group, settings|
    queue_records = {}
    queue_records['closed_prs'] = queue_records_from_file['closed_prs'].select do |repo, link|
      config['repos_to_groups'][repo] && config['repos_to_groups'][repo] == group
    end
    queue_records['running'] = queue_records_from_file['running'].select do |link, data|
      config['repos_to_groups'][data['repo']] && config['repos_to_groups'][data['repo']] == group
    end if queue_records_from_file['running']
    queue_records['enqueued'] = queue_records_from_file['enqueued'].select do |link, data|
      config['repos_to_groups'][data['repo']] && config['repos_to_groups'][data['repo']] == group
    end if queue_records_from_file['enqueued']
    queue_records['failure'] = queue_records_from_file['failure'].select do |link, data|
      config['repos_to_groups'][data['repo']] && config['repos_to_groups'][data['repo']] == group
    end if queue_records_from_file['failure']
    write_merge_queue_overview(settings['merge_queue_name'], config, queue_records, erb)
  end
  # Handle the case where ungrouped and grouped repos are handled by same config
  queue_records = {}
  queue_records['closed_prs'] = queue_records_from_file['closed_prs'].select do |repo, link|
    config['repos_to_groups'][repo].nil? || config['repos_to_groups'][repo].empty?
  end
  queue_records['running'] = queue_records_from_file['running'].select do |link, data|
    config['repos_to_groups'][data['repo']].nil? || config['repos_to_groups'][data['repo']].empty?
  end if queue_records_from_file['running']
  queue_records['enqueued'] = queue_records_from_file['enqueued'].select do |link, data|
    config['repos_to_groups'][data['repo']].nil? || config['repos_to_groups'][data['repo']].empty?
  end if queue_records_from_file['enqueued']
  queue_records['failure'] = queue_records_from_file['failure'].select do |link, data|
    config['repos_to_groups'][data['repo']].nil? || config['repos_to_groups'][data['repo']].empty?
  end if queue_records_from_file['failure']
  if queue_records['closed_prs'] || queue_records['running'] || queue_records['enqueued'] || queue_records['failure']
    puts "qr: #{queue_records}"
    write_merge_queue_overview(config['merge_queue_name'], config, queue_records, erb)
  end
  else
  write_merge_queue_overview(config['merge_queue_name'], config, queue_records_from_file, erb)
end


