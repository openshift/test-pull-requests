#!/usr/bin/env ruby

# Client script for submitting pull requests for testing
# as well as updating the test results from Jenkins.
#
# This script requires that the 'hub' rubygem be installed
# which provides the OAuth functionality as well as some
# other core functionality.
#
# You should be able to install 'hub' with:
#   sudo gem install hub
#
# This has to be manually run one time to establish an OAuth
# ticket.  The user setting in .test_pull_requests.json is bot_github_user

require 'rubygems'
require 'uri'
require 'hub'
require 'pp'
require 'net/https'
require 'getoptlong'
require 'time'

def usage
  puts <<USAGE
Usage: test_pull_requests [--help] [--merge_pull_request <pull_id>] [--local_merge_pull_request <pull_id>] [--test_pull_request <pull_id>] [--repo <repo>]

This will process all the setting specified pull requests and submit
Jenkins tests for any mergeable pull requests

Options:
-h|--help
    Show Usage info
--merge_pull_request <pull_id>
    Takes the id of the pull request to merge and merges into the branch specified by the pull request
--local_merge_pull_request <pull_id>
    Takes the id of the pull request to merge and locally merges into the branch specified by the pull request
--test_merge_pull_request <pull_id>
    Takes the id of the pull request to merge and makes sure the merge will succeed before actually merging
--mark_test_success <pull_id>
    Marks a pull request with success status for the test_settings configuration
--mark_testonlyextended_success <pull_id>
    Marks a pull request with success status for the testonlyextended_settings configuration
--merge_pretest_success
    Merges all of the pretested pull requests
--repo <repo>
    The repo of the pull request
USAGE
  exit 255
end

opts = GetoptLong.new(
["--help",               "-h",      GetoptLong::NO_ARGUMENT],
["--merge_pull_request",            GetoptLong::REQUIRED_ARGUMENT],
["--local_merge_pull_request",      GetoptLong::REQUIRED_ARGUMENT],
["--test_merge_pull_request",       GetoptLong::REQUIRED_ARGUMENT],
["--mark_test_success",             GetoptLong::REQUIRED_ARGUMENT],
["--mark_testonlyextended_success", GetoptLong::REQUIRED_ARGUMENT],
["--merge_pretest_success",         GetoptLong::NO_ARGUMENT],
["--repo",                          GetoptLong::REQUIRED_ARGUMENT],
["--config",                        GetoptLong::REQUIRED_ARGUMENT]
)

args = {}
begin
  opts.each{ |k,v| args[k[2..-1].intern]=v }
rescue GetoptLong::Error => e
  usage
end

if args[:help]
  usage
end

merge_pull_id = args[:merge_pull_request]
local_merge_pull_id = args[:local_merge_pull_request]
test_merge_pull_id = args[:test_merge_pull_request]
mark_test_success_pull_id = args[:mark_test_success]
mark_testonlyextended_success_pull_id = args[:mark_testonlyextended_success]
pull_id_repo = args[:repo]
config = args[:config]
merge_pretest_success = args[:merge_pretest_success]

include Hub

PROPERTIES_LOCATION = config || File.expand_path("~/.test_pull_requests.json")
Properties = if File.exists? PROPERTIES_LOCATION
  JSON.parse(IO.read(PROPERTIES_LOCATION))
else
  $stderr.puts "Properties file not found: #{PROPERTIES_LOCATION}"
  exit 255
end

# Branches and repos must be supported for all settings
$branches = []
$repos = []
Properties['settings'].values.each do |settings|
  settings['branches'].keys.each do |branch|
    $branches |= [branch]
  end
  settings['repo_to_teams'].keys.each do |repo|
    $repos |= [repo]
  end
end

$repo_to_pull_regex = {}
$repos.each do |repo|
  $repo_to_pull_regex[repo] = /https:\/\/github.com\/#{Properties['github_user']}\/#{repo}\/(pulls?|issues?)\/(\d+)/
end

$permissions = {}
$commits = {}
$submitted_tests = {}
$branches.each do |branch|
  $submitted_tests[branch] = {}
end

ACTION_PREFIX               = Properties['action_required_prefix']
ACTION_NOT_MERGE            = "#{ACTION_PREFIX} Pull request cannot be automatically merged, please rebase your branch from latest HEAD and push again"
ACTION_NOT_TEAM             = "#{ACTION_PREFIX} Please contact #{Properties['irc_channel']} to have this pull request manually reviewed and tested"
ACTION_UNSUPPORTED_BRANCH   = "#{ACTION_PREFIX} Only pull request(s) from #{$branches.pretty_inspect.chomp} are handled by the #{Properties['bot_github_user']}"
NEEDS_REBASE_LABEL          = "needs-rebase"

def evaluated_marker(repo, settings)
  "Evaluated for #{Properties['repo_to_product'][repo].downcase} #{settings['name']} up to %s"
end

def evaluated_marker_regex(repo, settings)
  /^Evaluated for #{Properties['repo_to_product'][repo].downcase} #{settings['name']} up to (.*)/
end

def branch_settings(branch, settings)
  s = nil
  if settings['branches'][branch]
    s = settings['branches'][branch]
  elsif settings['branches']['*']
    s = settings['branches']['*']
  end
  s
end

def submitted_tests_for_branch(branch)
  $submitted_tests[branch] ? $submitted_tests[branch] : $submitted_tests['*']
end

# Dynamically extend GitHubAPI to add methods that don't
# require a local git project
module Hub
  class GitHubAPI
    def list_pull_requests(repo, num_tries=3)
      pull_requests = []
      page = 1
      last_pull_requests = nil
      while (!last_pull_requests || last_pull_requests.length == 100)
        (1..num_tries).each do |i|
          res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/pulls?page=#{page}&per_page=100"
          rate_limit_remaining = res.header['X-RateLimit-Remaining']
          $stderr.puts "Rate limit remaining: #{rate_limit_remaining}"
          if rate_limit_remaining && rate_limit_remaining.to_i < 500
            $stderr.puts "WARNING: Skipping processing due to rate limit approaching!"
            exit 0
          end
          if res.success?
            last_pull_requests = res.data
            pull_requests += last_pull_requests
            page += 1
            break
          elsif i == num_tries
            $stderr.puts res.body
            res.error!
          end
        end
      end
      pull_requests
    end

    def get_pull_request(id, repo, num_tries=1)
      (1..num_tries).each do |i|
        res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/pulls/%s" % id
        if res.success?
          return res.data
        elsif i == num_tries
          res.error!
        else
          sleep 1
        end
      end
    end

    def is_mergeable?(id, repo, num_tries=3)
      # This call isn't reliable so make sure
      (1..num_tries).each do |i|
        pull_request = get_pull_request(id, repo, num_tries)
        mergeable = pull_request['mergeable']
        # Mergeable has become unreliable.  Resort to mergeable state for now if nil.
        # TODO: Re-evaluate this at a later date
        if mergeable.nil?
          case pull_request['mergeable_state']
          when 'checking', 'dirty', 'unstable'
            mergeable = false
          when 'unknown', 'clean', 'stable'
            mergeable = !pull_request['merged']
          end
        end
        return true if mergeable
        sleep 1 if i > 1 && i < num_tries
      end
      return false
    end

    def get_last_commit(id, repo, num_tries=3)
      commits = nil
      if $commits[repo]
        commits = $commits[repo][id]
      else
        $commits[repo] = {}
      end
      unless commits
        (1..num_tries).each do |i|
          res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/pulls/%s/commits?per_page=100" % id
          if res.success?
            commits = res.data
            $commits[repo][id] = commits
            break
          elsif i == num_tries
            res.error!
          end
        end
      end
      commits.last
    end

    def get_comments(issue_id, repo, num_tries=3)
      page = 1
      comments = []
      last_comments = nil
      while (!last_comments || last_comments.length == 100)
        (1..num_tries).each do |i|
          res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/%s/comments?page=#{page}&per_page=100" % issue_id
          if res.success?
            last_comments = res.data
            comments += last_comments
            page += 1
            break
          end
          res.error! if i == num_tries
        end
      end
      comments
    end

    def delete_comment(comment_id, repo, num_tries=3)
      $stderr.puts "  Deleting comment ##{comment_id}"
      (1..num_tries).each do |i|
        res = delete "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/comments/%s" % [comment_id]
        break if res.success?
        res.error! if i == num_tries
      end
    end

    def add_comment(issue_id, repo, comment, num_tries=3)
      params = { :body => comment }
      (1..num_tries).each do |i|
        res = post "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/%s/comments" % [issue_id], params
        return res.data if res.success?
        res.error! if i == num_tries
      end
    end

    def update_comment(comment_id, repo, comment, num_tries=3)
      $stderr.puts "  Updating comment ##{comment_id} with #{comment}"
      params = { :body => comment }
      (1..num_tries).each do |i|
        res = post "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/comments/%s" % [comment_id], params
        return res.data if res.success?
        res.error! if i == num_tries
      end
    end

    def recreate_comment(issue_id, comment_id, repo, comment)
      $stderr.puts "  Recreating comment ##{comment_id} with #{comment}"
      delete_comment(comment_id, repo)
      add_comment(issue_id, repo, comment)
    end

    def ensure_labels(issue_id, repo, labels, num_tries=3)
      existing_labels = get_labels(issue_id, repo, num_tries)
      existing_labels = existing_labels.map{|label| label['name']}
      missing_labels = labels - existing_labels
      if missing_labels.length > 0
        add_labels(issue_id, repo, missing_labels, num_tries)
      end
    end

    def add_labels(issue_id, repo, labels, num_tries=3)
      $stderr.puts "  Adding labels: #{labels.join(',')}"
      (1..num_tries).each do |i|
        res = post "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/%s/labels" % [issue_id], labels
        return res.data if res.success?
        res.error! if i == num_tries
      end
    end

    def remove_labels(issue_id, repo, labels, num_tries=3)
      existing_labels = get_labels(issue_id, repo, num_tries)
      existing_labels = existing_labels.map{|label| label['name']}
      labels = labels & existing_labels
      labels.each do |label|
        remove_label(issue_id, repo, label, num_tries)
      end
    end

    def remove_label(issue_id, repo, label, num_tries=3)
      $stderr.puts "  Removing label #{label}"
      (1..num_tries).each do |i|
        res = delete "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/%s/labels/%s" % [issue_id, label]
        break if res.success?
        res.error! if i == num_tries
      end
    end

    def get_labels(issue_id, repo, num_tries=3)
      page = 1
      labels = []
      last_labels = nil
      while (!last_labels || last_labels.length == 100)
        (1..num_tries).each do |i|
          res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/issues/%s/labels?page=#{page}&per_page=100" % issue_id
          if res.success?
            last_labels = res.data
            labels += last_labels
            page += 1
            break
          end
          res.error! if i == num_tries
        end
      end
      labels
    end

    def update_status(context, sha, repo, state, url, desc, num_tries=3)
      $stderr.puts "  Updating status of '#{sha}' with state '#{state}'"
      params = { :state => state, :target_url => url, :description => desc, :context => context}
      (1..num_tries).each do |i|
        res = post "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/statuses/%s" % [sha], params
        return res.data if res.success?
        #res.error! if i == num_tries
      end
    end

    def get_last_status(context, sha, repo, num_tries=3)
      (1..num_tries).each do |i|
        res = get "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/commits/#{sha}/statuses?per_page=100"
        if res.success?
          last_status = nil
          res.data.each do |status|
            if status['context'] == context
              last_status = status
              break
            end
          end
          return last_status
        end
        res.error! if i == num_tries
      end
    end

    # Verifies the user is part of a valid team
    def user_trusted?(login, repo, settings)
      trusted = false
      repo_setting_key = "#{repo}_#{settings['name']}"
      if $permissions[login]
        if $permissions[login][repo_setting_key]
          trusted = $permissions[login][repo_setting_key] ? true : false
        end
      else
        $permissions[login] = {}
      end
      if $permissions[login][repo_setting_key].nil?
        settings['repo_to_teams'][repo].each do |team|
          res = get "https://api.github.com/teams/#{team}/members/#{login}"
          trusted = res.success?
          break if trusted
        end
        $permissions[login][repo_setting_key] = trusted
      end
      trusted
    end

    # Submit tests to Jenkins and update the comment
    def submit_tests(repo_to_pull_request, base_repo, branch, comment_id, extended_tests, settings)
      submitted_tests = submitted_tests_for_branch(branch)
      unless settings['allow_multiple']
        if submitted_tests[settings['name']] || JenkinsAPI.is_previous_build_running?(branch, settings)
          submitted_tests[settings['name']] = true
          $stderr.puts "  Waiting for existing build to finish"
          return
        end
      end

      # If the project is stable, submit the tests
      build_url = JenkinsAPI.submit_jenkins_job(repo_to_pull_request, branch, extended_tests, settings)

      running_comment = "#{settings['test_prefix']} Running (#{build_url})"
      running_comment += " (Extended Tests: #{extended_tests.join(', ')})" unless extended_tests.empty?

      # Update the comments to reflect the new tests running
      update_comment(comment_id, base_repo, running_comment)

      repo_to_pull_request.each do |repo, pull_request|
        if repo != base_repo
          process_or_create_comment(pull_request['number'], repo, settings) do |comment_id, comment, comment_updated_at|
            update_comment(comment_id, repo, running_comment)
          end
        end
        commit = get_last_commit(pull_request['number'], repo)
        update_status(settings['test_prefix'], commit['sha'], repo, 'pending', build_url, "Testing")
      end

      submitted_tests[settings['name']] = true unless settings['allow_multiple']
    end

    def mark_test_success(pull_id, repo, settings)
      $stderr.puts "  Marking SUCCESS for pull request ##{pull_id} in repo '#{repo}'"
      bot_comment = get_comment_with_prefix(pull_id, repo, settings['test_prefix'])
      build_url = nil
      extended_tests = nil
      if bot_comment['body'] =~ /^#{settings['test_prefix']} Running \(([^\)]+)\)( \(Extended Tests: [^\)]+\))?/
        build_url = $1
        extended_tests = $2
      else
        raise "'#{settings['name']}' pull request not found"
      end
      comment = "#{settings['test_prefix']} SUCCESS (#{build_url})"
      comment += extended_tests if extended_tests
      recreate_comment(pull_id, bot_comment['id'], repo, comment)

      commit = get_last_commit(pull_id, repo)
      update_status(settings['test_prefix'], commit['sha'], repo, 'success', build_url, "Tested")
    end

    def merge_pull_request(pull_id, repo, settings, merge_pretest_success_url=nil)
      $stderr.puts "  Merging pull request ##{pull_id} for repo '#{repo}'"
      pull_request, bot_comment, comments = test_merge_pull_request(pull_id, repo, settings)
      build_url = nil
      if merge_pretest_success_url
        build_url = merge_pretest_success_url
      elsif bot_comment['body'] =~ /^#{settings['test_prefix']} Running \((.*)\)/
        build_url = $1
      else
        raise "'#{settings['name']}' pull request not found"
      end
      comment = "#{settings['test_prefix']} SUCCESS (#{build_url})"
      begin
        branch = pull_request['base']['ref']
        b_settings = branch_settings(branch, settings)
        image_base_name = b_settings['image_base_name']
        if image_base_name
          image_base_name.gsub!('*', branch)
          image = "#{image_base_name}_#{JenkinsAPI.get_next_build(branch, settings, b_settings['downstream_job_name'])}"
          comment = "#{comment} (Image: #{image})"
        end
      rescue Exception => e
        $stderr.puts e.message
      end

      update_comment(bot_comment['id'], repo, comment)
      params = { :commit_message => "Merged by #{Properties['bot_github_user']}" }
      sleep_time = 1
      res = nil
      num_tries = 5
      (1..num_tries).each do |i|
        res = put "https://api.github.com/repos/#{Properties['github_user']}/#{repo}/pulls/#{pull_id}/merge", params
        break if res.success?
        if i < num_tries
          sleep sleep_time
          sleep_time *= 2
          $stderr.puts "  Retrying...  attempt: #{i+1}"
        end
      end

      res.error! unless res.success?

      if settings['trello_card_refs']
        settings['trello_card_refs'].each do |ref|
          values = get_values_from_pull_request(pull_id, repo, /(#{ref}_\d+)/i, pull_request, comments)
          values.each do |value|
            comment = "A pull request referencing this card has been merged: https://github.com/#{Properties['github_user']}/#{repo}/pull/#{pull_id}"
            $stderr.puts `trello comment '#{comment}' --card-ref #{value}`
          end
        end
        values = get_values_from_pull_request(pull_id, repo, /(https?:\/\/trello\.com\/c\/[[:alnum:]]+)/, pull_request, comments)
        values.each do |value|
          comment = "A pull request referencing this card has been merged: https://github.com/#{Properties['github_user']}/#{repo}/pull/#{pull_id}"
          $stderr.puts `trello comment '#{comment}' --card-url '#{value}'`
        end
      end

      commit = get_last_commit(pull_request['number'], repo)
      update_status(settings['test_prefix'], commit['sha'], repo, 'success', build_url, "Merged")
    end

    def test_merge_pull_request(pull_id, repo, settings)
      $stderr.puts "  Test merging pull request ##{pull_id} for repo '#{repo}'"
      comments = get_comments(pull_id, repo)
      bot_comment = get_comment_with_prefix(pull_id, repo, settings['test_prefix'], comments)
      raise "Missing '#{settings['test_prefix']}' comment!" if bot_comment.nil?
      evaluated_time = get_evaluated_time(comments, repo, settings)
      raise "Missing evaluated flag!" if evaluated_time.nil?
      pull_request = get_pull_request(pull_id, repo, 10)
      raise "Pull request isn't open!" unless pull_request['state'] == 'open'
      mergeable = pull_request['mergeable']
      # This call isn't reliable so make sure
      mergeable = is_mergeable?(pull_id, repo, 10) unless mergeable
      raise "Pull request isn't mergeable!" unless mergeable
      pull_request_updated_at, pull_request_changed_after_eval = get_updated_at(pull_request, comments, settings)
      unless !pull_request_changed_after_eval
        $stderr.puts "  Evaluated time: #{evaluated_time}"
        $stderr.puts "  Updated at: #{pull_request_updated_at}"
        raise "Pull request was updated after testing started!"
      end
      return pull_request, bot_comment, comments
    end

    def local_merge_pull_request(pull_id, repo)
      $stderr.puts "Local merging pull request ##{pull_id} for repo '#{repo}'"
      pull_request = get_pull_request(pull_id, repo, 10)
      merge_command = %{
set -ex
pushd #{repo}
  git checkout #{pull_request['base']['ref']}
  git checkout -b tpr_#{pull_request['head']['ref']}_#{pull_request['user']['login']}
  git pull #{pull_request['head']['repo']['ssh_url']} #{pull_request['head']['ref']}
  git pull #{pull_request['head']['repo']['ssh_url']} #{pull_request['head']['ref']} --tags
  git checkout #{pull_request['base']['ref']}
  git merge tpr_#{pull_request['head']['ref']}_#{pull_request['user']['login']}
popd
}
      output = `#{merge_command}`
      exit_code = $?.exitstatus
      puts output
      exit 1 if exit_code != 0
    end

    def put url, params = nil
      perform_request url, :Put do |req|
        if params
          req.body = JSON.dump params
          req['Content-Type'] = 'application/json;charset=utf-8'
        end
        req['User-Agent'] = Properties['bot_github_user']
        yield req if block_given?
        req['Content-Length'] = req.body ? req.body.length : 0
      end
    end

    def post url, params = nil
      perform_request url, :Post do |req|
        if params
          req.body = JSON.dump params
          req['Content-Type'] = 'application/json;charset=utf-8'
          req['User-Agent'] = Properties['bot_github_user']
        end
        yield req if block_given?
        req['Content-Length'] = req.body ? req.body.length : 0
      end
    end

    def perform_request url, type
      url = URI.parse url unless url.respond_to? :host

      require 'net/https'
      req = Net::HTTP.const_get(type).new request_uri(url)
      req['User-Agent'] = Properties['bot_github_user']

      http = configure_connection(req, url) do |host_url|
        create_connection host_url
      end

      apply_authentication(req, url)
      yield req if block_given?

      begin
        res = http.start { http.request(req) }
        res.extend ResponseMethods
        return res
      rescue SocketError => err
        raise Context::FatalError, "error with #{type.to_s.upcase} #{url} (#{err.message})"
      end
    end


    def delete url
      perform_request url, :Delete do |req|
        req['User-Agent'] = Properties['bot_github_user']
        yield req if block_given?
      end
    end

    #
    # Yields on the OpenShift bot comment with the test results.
    # Creates a placeholder comment if none exist
    #
    def process_or_create_comment(issue_id, repo, settings, comments=nil)
      bot_comment = get_comment_with_prefix(issue_id, repo, settings['test_prefix'], comments)

      unless bot_comment
        bot_comment = get_comment_with_prefix(issue_id, repo, settings['test_prefix'])
        unless bot_comment
          # No comment found, create a new one and yield to it
          $stderr.puts "  Creating placeholder comment"
          evaluating_comment = "#{settings['test_prefix']} Evaluating for testing"
          bot_comment = add_comment(issue_id, repo, evaluating_comment)
        end
      end

      yield bot_comment['id'], bot_comment['body'], Time.parse(bot_comment['updated_at'])
    end

    #
    # Creates or updates a comment with given prefix
    #
    def create_or_update_comment(issue_id, repo, comment_prefix, comment, comments=nil)
      bot_comment = get_comment_with_prefix(issue_id, repo, comment_prefix, comments)

      if bot_comment
        update_comment(bot_comment['id'], repo, comment) if bot_comment['body'] != comment
      else
        # No comment found, create a new one
        add_comment(issue_id, repo, comment)
      end

    end

    #
    # Creates or updates a comment with given prefix
    #
    def delete_comment_with_prefix(issue_id, repo, comment_prefix, comments=nil)
      comment = get_comment_with_prefix(issue_id, repo, comment_prefix, comments)
      if comment && comments
        comments.delete_if { |c| c['id'] == comment['id'] }
      end
      delete_comment(comment['id'], repo) if comment
      return comment
    end

    #
    # Gets a comment with given prefix
    #
    def get_comment_with_prefix(issue_id, repo, comment_prefix, comments=nil)
      prefix_comment = nil

      comments = comments ? comments : get_comments(issue_id, repo)

      # See if we can find an existing bot comment
      comments.each do |comment|
        if comment['body'] =~ /^#{comment_prefix}/ && (comment['user']['login'] == Properties['bot_github_user'])
          prefix_comment = comment
          break
        end
      end

      prefix_comment
    end

    #
    # Gets a comment with given prefix
    #
    def recreate_comment_with_prefix(issue_id, repo, comment_prefix, comment, comments=nil)
      comments = get_comments(issue_id, repo) if comments.nil?
      delete_comment_with_prefix(issue_id, repo, comment_prefix, comments)
      create_or_update_comment(issue_id, repo, comment_prefix, comment, comments)
    end

    def get_comment_with_value(issue_id, repo, value, comments=nil)
      comment = nil

      comments = comments ? comments : get_comments(issue_id, repo)

      # See if we can find an existing bot comment
      comments.each do |c|
        if c['body'] == value && (c['user']['login'] == Properties['bot_github_user'])
          comment = c
          break
        end
      end

      comment
    end

    def get_values_from_pull_request(issue_id, repo, value_regex, pull_request, comments=nil)
      values = []

      comments = comments ? comments : get_comments(issue_id, repo)

      add_values_by_regex(pull_request['title'], value_regex, values)
      add_values_by_regex(pull_request['body'], value_regex, values)

      comments.each do |c|
        add_values_by_regex(c['body'], value_regex, values)
      end
      values.uniq!
      values
    end

    def add_values_by_regex(content, value_regex, values)
      if content
        index = 0
        while index do
          index = content.index(value_regex, index)
          if index
            value = $1
            index += value.length
            values << value
          end
        end
      end
    end

    def get_evaluated_time(comments, repo, settings)
      comments = sort_comments(comments)

      comments.each do |comment|
        if comment['user']['login'] == Properties['bot_github_user'] && comment['body'] =~ evaluated_marker_regex(repo, settings)
          return Time.parse(comment['updated_at'])
        end
      end
      return nil
    end

    def get_trusted_trigger_time(pull_request, comments, settings)
      login = pull_request['user']['login']
      updated_at, changed_after_eval = get_updated_at(pull_request, comments, settings)
      repo = pull_request['base']['repo']['name']

      trigger_regex = /\[#{settings['name']}\]/i
      trigger_time = nil
      trigger_login = nil
      if pull_request['title'] =~ trigger_regex || pull_request['body'] =~ trigger_regex
        if user_trusted?(login, repo, settings)
          evaluated_time = get_evaluated_time(comments, repo, settings)
          trigger_time = evaluated_time || Time.parse(pull_request['updated_at'])
          trigger_login = login
        end
      end

      comments = sort_comments(comments)

      comments.each do |comment|
        if comment['body'] =~ trigger_regex
          comment_login = comment['user']['login']
          if user_trusted?(comment_login, repo, settings)
            trigger_comment_updated_at = Time.parse(comment['updated_at'])
            if user_trusted?(login, repo, settings) || trigger_comment_updated_at > updated_at
              if !trigger_time || trigger_comment_updated_at > trigger_time
                trigger_time = trigger_comment_updated_at
                trigger_login = comment_login
              end
              break
            end
          end
        end
      end
      return [trigger_time, trigger_login]
    end

    def get_extended_tests(pull_request, comments, settings)
      extended_tests = []
      if settings['allow_multiple']
        extended_regex = /\[extended *:( *[^,\[\]]+ *(, *[^,\[\]]+ *)*)\]/i
        if pull_request['title'] =~ extended_regex
          extended_tests += $1.split(',')
        end

        if pull_request['body'] =~ extended_regex
          extended_tests += $1.split(',')
        end

        comments.each do |comment|
          if comment['body'] =~ extended_regex
            extended_tests += $1.split(',')
          end
        end
        extended_tests.each do |test|
          test.downcase!
          test.strip!
        end
        extended_tests.uniq!
      end
      return extended_tests
    end

    def sort_comments(comments)
      comments = comments.sort_by do |comment|
        Time.parse(comment['updated_at'])
      end
      comments.reverse!
      comments
    end

    # Updates all the bot markers for the involved pull requests.  To be called after you have validated the tests should be kicked off again
    def update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings)
      repo_to_pull_request.each do |repo, pull_request|
        pull_request_comments = get_comments(pull_request['number'], repo)
        test_prefix_comment = get_comment_with_prefix(pull_request['number'], repo, settings['test_prefix'], pull_request_comments)
        if !test_prefix_comment || !(test_prefix_comment['body'] =~ /^#{settings['test_prefix']} Waiting/)
          being_queued_comment = "#{settings['test_prefix']} Waiting: Determining build queue position"
          create_or_update_comment(pull_request['number'], repo, settings['test_prefix'], being_queued_comment, pull_request_comments)
        end
        pull_request_evaluated_time = get_evaluated_time(pull_request_comments, repo, settings)
        pull_request_updated_at, pull_request_changed_after_eval = get_updated_at(pull_request, pull_request_comments, settings)
        if pull_request_changed_after_eval || pull_request_evaluated_time < trigger_updated_at
          commit = get_last_commit(pull_request['number'], repo)
          # Add a new evaluated marker
          add_comment(pull_request['number'], repo, (evaluated_marker(repo, settings) % commit['sha']))
          # Delete the old evaluated markers
          pull_request_comments.each do |comment|
            if comment['user']['login'] == Properties['bot_github_user'] && comment['body'] =~ evaluated_marker_regex(repo, settings)
              delete_comment(comment['id'], repo)
            end
          end
        end
      end
    end

    def get_updated_at(pull_request, comments, settings)
      updated_at = nil
      comments = sort_comments(comments)
      previous_sha = nil
      comments.each do |comment|
        if comment['user']['login'] == Properties['bot_github_user'] && comment['body'] =~ evaluated_marker_regex(pull_request['base']['repo']['name'], settings)
          previous_sha = $1
        end
      end
      commit = get_last_commit(pull_request['number'], pull_request['base']['repo']['name'])

      changed_after_eval = true
      if commit['sha'] == previous_sha
        changed_after_eval = false
      end
      #GitHub API isn't consistent here
      updated_at_str = nil
      if commit.has_key?('commit')
        updated_at_str = commit['commit']['committer']['date']
      else
        updated_at_str = commit['committer']['date']
      end

      updated_at = Time.parse(updated_at_str)
      [updated_at, changed_after_eval]
    end

    def add_coreq(addtl_pull_id, addtl_pull_repo, login, trigger_login, repo_to_pull_request, settings, trigger_updated_at, updated_at, base_pull_id, base_repo, comments)
      $stderr.puts "  Processing dependency on pull request #{addtl_pull_id} in repo '#{addtl_pull_repo}'"
      trusted = user_trusted?(login, addtl_pull_repo, settings)
      # It's ok if the user is trusted or the trigger was added after the comment
      if trusted || (user_trusted?(trigger_login, addtl_pull_repo, settings) && (trigger_updated_at && trigger_updated_at >= updated_at))
        pull_request = get_pull_request(addtl_pull_id, addtl_pull_repo, 2)
        if pull_request
          if pull_request['mergeable']
            repo_to_pull_request[addtl_pull_repo] = pull_request
            set_mergeable(addtl_pull_id, addtl_pull_repo, pull_request['user']['login'])
          else
            if set_not_mergeable(addtl_pull_id, addtl_pull_repo, pull_request['user']['login']) > 4
              comment = "Linked pull request #{addtl_pull_id} in repo '#{addtl_pull_repo}' is not mergeable"
              $stderr.puts "  #{comment}"
              add_comment(base_pull_id, base_repo, comment) unless get_comment_with_value(base_pull_id, base_repo, comment, comments)
            end
          end
        else
          comment = "Linked pull request #{addtl_pull_id} in repo '#{addtl_pull_repo}' not found"
          $stderr.puts "  #{comment}"
          add_comment(base_pull_id, base_repo, comment) unless get_comment_with_value(base_pull_id, base_repo, comment, comments)
        end
      else
        comment = "User '#{login}' is not permitted to #{settings['name']} linked pull request #{addtl_pull_id} in '#{addtl_pull_repo}'.  If the #{settings['name']} was requested by another user with permission to #{settings['name']} in '#{addtl_pull_repo}', the linked pull request must be in a comment before the #{settings['name']} comment (not including the pull request description) or be added by a user with permission to #{settings['name']} in '#{addtl_pull_repo}'."
        $stderr.puts "  #{comment}"
        add_comment(base_pull_id, base_repo, comment) unless get_comment_with_value(base_pull_id, base_repo, comment, comments)
      end
    end

    #
    # Processes a specific pull request.  Manages the various comment
    # states and will submit tests as necessary and update the comment
    # with the results.  Tests will be resubmitted if the issue has
    # been updated since the test have been run
    #
    def process_pull_request(req, updated_at, changed_after_eval, comments, settings, merge_pretest_success)
      id = req['number']
      branch = req['base']['ref']
      base_repo = req['base']['repo']['name']
      login = req['user']['login']
      repo_to_pull_request = {base_repo => req}

      $stderr.puts "\n****Processing #{settings['name'].upcase} in '#{branch}' branch for user '#{login}' on: https://github.com/#{Properties['github_user']}/#{base_repo}/pull/#{id}"

      trigger_updated_at, trigger_login = get_trusted_trigger_time(req, comments, settings)

      evaluated_time = get_evaluated_time(comments, base_repo, settings)

      $stderr.puts "  Updated at: #{updated_at}"
      $stderr.puts "  Changed after evaluated time: #{changed_after_eval}"
      $stderr.puts "  Trigger updated at: #{trigger_updated_at}"
      $stderr.puts "  Evaluated time: #{evaluated_time}"

      # Gather any dependencies from trusted users
      $repo_to_pull_regex.each do |repo, regex|
        next if repo == base_repo
        if req['body'] =~ regex
          addtl_pull_id = $2
          add_coreq(addtl_pull_id, repo, login, trigger_login, repo_to_pull_request, settings, trigger_updated_at, Time.parse(req['updated_at']), id, base_repo, comments)
        end
      end

      comments.each do |comment|
        $repo_to_pull_regex.each do |repo, regex|
          next if repo == base_repo
          if comment['body'] =~ regex
            addtl_pull_id = $2
            add_coreq(addtl_pull_id, repo, comment['user']['login'], trigger_login, repo_to_pull_request, settings, trigger_updated_at, Time.parse(comment['updated_at']), id, base_repo, comments)
          end
        end
      end

      updated_comment = nil
      status = nil
      build_url = nil
      # Find the bot comment for this pull request (or create one)
      process_or_create_comment(id, base_repo, settings, comments) do |comment_id, comment, comment_updated_at|
        submit_test_job = false
        resubmit_test_job = false
        case comment
        when /^#{settings['test_prefix']} Evaluating/
          $stderr.puts "  Evaluating..."
          # This is the state for a completely new comment

          if JenkinsAPI.is_project_stable?(branch, settings)
            # Make sure there is a trigger in place that is still later than the updated dates of each of the pull requests
            if trigger_updated_at
              repo_to_pull_request.each do |repo, pull_request|
                next if repo == base_repo
                if !user_trusted?(pull_request['user']['login'], repo, settings) && trigger_updated_at < Time.parse(pull_request['head']['repo']['updated_at'])
                  create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
                  break
                end
              end
              update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings)
              submit_test_job = true
            else
              create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
            end
          else
            updated_comment = "#{settings['test_prefix']} Waiting for stable build of '#{branch_settings(branch, settings)['downstream_job_name']}'"
          end
        when /^#{settings['test_prefix']} Waiting/
          $stderr.puts "  Waiting..."
          # Only submit the tests if the project is stable
          if JenkinsAPI.is_project_stable?(branch, settings)
            submitted_tests = submitted_tests_for_branch(branch)
            if !(submitted_tests[settings['name']] && comment =~ /^#{settings['test_prefix']} Waiting: You are in the build queue at position: \d+/)
              $stderr.puts "  Checking that evaluated times are still up to date"
              if changed_after_eval
                resubmit_test_job = true
              else
                submit_test_job = true
                repo_to_pull_request.each do |repo, sub_pull_request|
                  next if repo == base_repo
                  $stderr.puts "  Checking evaluated time for sub pull request #{sub_pull_request['number']} for repo '#{repo}'"
                  sub_pull_comments = get_comments(sub_pull_request['number'], repo)
                  sub_pull_request_updated_at, sub_pull_request_changed_after_eval = get_updated_at(sub_pull_request, sub_pull_comments, settings)

                  $stderr.puts "  Updated at: #{sub_pull_request_updated_at}"
                  $stderr.puts "  Changed after evaluated time: #{sub_pull_request_changed_after_eval}"
                  if sub_pull_request_changed_after_eval
                    resubmit_test_job = true
                    break
                  end
                end
              end
            else
              $stderr.puts "  Job is already queued"
            end
          end
        when /^#{settings['test_prefix']} Running \(([^\)]+)\)( \(Extended Tests: [^\)]+\))?/
          # This state means that the tests are already running
          # In this case we need to poll Jenkins to see if the build
          # is finished

          # Capture the build_url from the regex match
          build_url = $1
          extended_tests = $2
          $stderr.puts "  Running: #{build_url}consoleFull"

          # If the build is finished, update with the results
          if JenkinsAPI.is_build_running?(build_url, branch, settings)
            submitted_tests = submitted_tests_for_branch(branch)
            submitted_tests[settings['name']] = true unless settings['allow_multiple']
          else
            result = JenkinsAPI.get_build_result(build_url, branch, settings)
            updated_comment = "#{settings['test_prefix']} #{result} (#{build_url})"
            updated_comment += extended_tests if extended_tests
            status = result == 'SUCCESS' ? 'success' : 'failure'
          end
        else
          $stderr.puts "  Finished..."
          $stderr.puts "  #{comment}" if comment =~ /^#{settings['test_prefix']} .+ \([^\)]+\)/
          resubmit_test_job = true
        end
        if resubmit_test_job
          submit_test_job = false

          $stderr.puts "  Checking whether we should resubmit"
          if trigger_updated_at
            # We already trust the primary pull request.  Just need to check whether the eval time is older than last update or last trusted trigger.
            if changed_after_eval || (evaluated_time < trigger_updated_at)
              if JenkinsAPI.is_project_stable?(branch, settings)
                submit_test_job = true
              else
                updated_comment = "#{settings['test_prefix']} Waiting for stable build of '#{branch_settings(branch, settings)['downstream_job_name']}'"
              end
            end

            # Check for any other reason to submit the test job.  And make sure non of the sub pull requests have new untrusted changes.
            repo_to_pull_request.each do |repo, sub_pull_request|
              next if repo == base_repo

              $stderr.puts "  Checking evaluated time for sub pull request #{sub_pull_request['number']} for repo '#{repo}'"
              sub_pull_comments = get_comments(sub_pull_request['number'], repo)
              sub_pull_request_updated_at, sub_pull_request_changed_after_eval = get_updated_at(sub_pull_request, sub_pull_comments, settings)

              $stderr.puts "  Updated at: #{sub_pull_request_updated_at}"
              $stderr.puts "  Changed after evaluated time: #{sub_pull_request_changed_after_eval}"

              # Make sure the trigger on the primary pull request is after the updated date of the sub pull request
              # or the user of the sub pull request is trusted
              valid_trigger_comment = trigger_updated_at > sub_pull_request_updated_at
              $stderr.puts "  Has valid trigger comment: #{valid_trigger_comment}"
              if valid_trigger_comment || user_trusted?(sub_pull_request['user']['login'], repo, settings)
                if sub_pull_request_changed_after_eval
                  if JenkinsAPI.is_project_stable?(branch, settings)
                    submit_test_job = true
                  else
                    updated_comment = "#{settings['test_prefix']} Waiting for stable build of '#{branch_settings(branch, settings)['downstream_job_name']}'"
                  end
                end
              else
                create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
                submit_test_job = false
                break
              end
            end
          else
            create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
            submit_test_job = false
          end
          if submit_test_job
            update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings)
          end
        end
        if submit_test_job
          delete_comment_with_prefix(id, base_repo, ACTION_PREFIX, comments)
          extended_tests = get_extended_tests(req, comments, settings)
          submit_tests(repo_to_pull_request, base_repo, branch, comment_id, extended_tests, settings)
        elsif updated_comment
          recreate_comment(id, comment_id, base_repo, updated_comment)
          repo_to_pull_request.each do |repo, pull_request|
            if status && build_url
              commit = get_last_commit(pull_request['number'], repo)
              update_status(settings['test_prefix'], commit['sha'], repo, status, build_url, "Tested")
            end
            next if repo == base_repo
            recreate_comment_with_prefix(pull_request['number'], repo, settings['test_prefix'], updated_comment)
          end
        else
          Properties['settings'].each_value do |s|
            if s['pretest_settings_key'] && merge_pretest_success
              if Properties['settings'][s['pretest_settings_key']]['name'] == settings['name']
                if comment =~ /^#{settings['test_prefix']} SUCCESS \(([^\)]+)\)/
                  build_url = $1
                  trusted_trigger_time, trigger_login = get_trusted_trigger_time(req, comments, s)
                  if trusted_trigger_time
                    begin
                      repo_to_pull_request.each do |repo, pull_request|
                        test_merge_pull_request(pull_request['number'], repo, s)
                      end if repo_to_pull_request.length > 0
                      repo_to_pull_request.each do |repo, pull_request|
                        $stderr.puts "\n*******Merging pretested pull request: https://github.com/#{Properties['github_user']}/#{repo}/pull/#{pull_request['number']} "
                        merge_pull_request(pull_request['number'], repo, s, build_url)
                      end
                    rescue Exception => e
                      $stderr.puts e.message
                      $stderr.puts e.backtrace
                    end
                  end
                end
                break
              end
            end
          end
        end
      end

    end

    def set_mergeable(id, repo, login, comments=nil)
      merge_id="#{repo}_#{id}_#{login}"
      count = 0
      previous_merge_result=`grep #{merge_id} ~/test_pull_request_not_mergeable`.chomp
      if !previous_merge_result.empty? && previous_merge_result =~ /#{merge_id}=(\d+)/
        count = $1.to_i
      end
      if count <= 0
        `sed -i "/#{merge_id}=/d" ~/test_pull_request_not_mergeable`
        comments = get_comments(id, repo) if comments.nil?
        if delete_comment_with_prefix(id, repo, ACTION_NOT_MERGE, comments) || (rand(10) <= 1)
          remove_labels(id, repo, [NEEDS_REBASE_LABEL])
        end
      else
        `sed -i "/#{merge_id}=/d" ~/test_pull_request_not_mergeable && echo "#{merge_id}=#{(count-1).to_s}" >> ~/test_pull_request_not_mergeable`
      end
    end

    def set_not_mergeable(id, repo, login)
      merge_id="#{repo}_#{id}_#{login}"
      count = 0
      previous_merge_result=`grep #{merge_id} ~/test_pull_request_not_mergeable`.chomp
      if !previous_merge_result.empty? && previous_merge_result =~ /#{merge_id}=(\d+)/
        count = $1.to_i
      end
      if count >= 5
        create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_NOT_MERGE)
        ensure_labels(id, repo, [NEEDS_REBASE_LABEL])
      else
        `sed -i "/#{merge_id}=/d" ~/test_pull_request_not_mergeable && echo "#{merge_id}=#{(count+1).to_s}" >> ~/test_pull_request_not_mergeable`
      end
      count #return count of how many times this has happened (used as stability measure, Github becomes unstable for mergeability right after a merge happens)
    end

    #
    # Processes a list of the valid pull requests that are mergeable
    # and are submitted by a trusted user
    #
    def process_pull_requests(merge_pretest_success)
      pull_requests = []
      mergeability_in_flux = false
      $repo_to_pull_regex.keys.each do |repo|
        $stderr.puts "Processing repo '#{repo}'"
        list_pull_requests(repo).each do |req|
          id = req['number']
          $stderr.puts "Analyzing pull request ##{id}"

          branch = req['base']['ref']

          if $branches.include?(branch) || $branches.include?('*')

            $stderr.puts "  Updated at: #{Time.parse(req['updated_at'])}"
            if Time.now - Time.parse(req['updated_at']) < (24*60*60) || (rand(20) <= 1)
              login = req['user']['login']
              comments = nil
              # Skip if it's not mergeable
              mergeable = is_mergeable?(id, repo)
              $stderr.puts "  Mergeable: #{mergeable}"
              if mergeable
                comments = get_comments(id, repo) if comments.nil?
                set_mergeable(id, repo, login, comments)
              else
                if set_not_mergeable(id, repo, login) == 0
                  mergeability_in_flux = true
                end
                next
              end

              comments = get_comments(id, repo) if comments.nil?

              permission_denied = Array.new(Properties['settings'].length, false)
              # Has a merge or test been requested by a trusted user?
              Properties['settings'].values.each_with_index do |settings, i|
                updated_at, changed_after_eval = get_updated_at(req, comments, settings)
                trigger_regex = /\[#{settings['name']}\]/i
                if req['title'] =~ trigger_regex || req['body'] =~ trigger_regex
                  if user_trusted?(login, repo, settings)
                    pull_requests << [req, updated_at, changed_after_eval, comments, settings]
                    permission_denied[i] = false
                    next
                  else
                    $stderr.puts "  User '#{login}' not trusted"
                    permission_denied[i] = true
                  end
                end

                comments = sort_comments(comments)
                comments.each do |comment|
                  if comment['body'] =~ trigger_regex
                    comment_login = comment['user']['login']
                    if user_trusted?(comment_login, repo, settings)
                      pull_requests << [req, updated_at, changed_after_eval, comments, settings]
                      permission_denied[i] = false
                      break
                    else
                      $stderr.puts "  User '#{comment_login}' not trusted"
                      permission_denied[i] = true
                    end
                  end
                end
              end
              if permission_denied.include? true
                create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
              end
            else
              $stderr.puts "  Skipping due to age and inactivity"
            end
          else
            create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_UNSUPPORTED_BRANCH)
          end
        end
      end

      if mergeability_in_flux
        $stderr.puts "Waiting till next run to see if mergeability is in flux"
        exit
      end

      sorted_pull_requests = pull_requests.sort_by do |req_info|
        req_info[1]
      end

      skipped_count = {}
      $branches.each do |branch|
        skipped_count[branch] = {}
      end
      sorted_pull_requests.each do |req_info|
        # Process the pull request
        req = req_info[0]
        updated_at = req_info[1]
        changed_after_eval = req_info[2]
        comments = req_info[3]
        settings = req_info[4]
        process_pull_request(req, updated_at, changed_after_eval, comments, settings, merge_pretest_success)

        branch = req['base']['ref']

        submitted_tests = submitted_tests_for_branch(branch)

        if !settings['allow_multiple'] && submitted_tests[settings['name']]
          comments = get_comments(req['number'], req['base']['repo']['name'])

          bot_comment = get_comment_with_prefix(req['number'], req['base']['repo']['name'], settings['test_prefix'], comments)
          if bot_comment && (bot_comment['body'] =~ /^#{settings['test_prefix']} Waiting/)
            skipped_count_branch = skipped_count[branch] ? skipped_count[branch] : skipped_count['*']
            skipped_count_branch[settings['name']] = 0 if skipped_count_branch[settings['name']].nil?
            skipped_count_branch[settings['name']] += 1
            queued_comment = "#{settings['test_prefix']} Waiting: You are in the build queue at position: #{skipped_count_branch[settings['name']].to_s}"
            create_or_update_comment(req['number'], req['base']['repo']['name'], settings['test_prefix'], queued_comment , comments)
            $stderr.puts "  Pull ##{req['number']} in repo '#{req['base']['repo']['name']}' is at build position ##{skipped_count_branch[settings['name']]}"
            # Get ahead of the game and pretest requests
            if settings['pretest_settings_key'] && settings['pretest_comment'] && settings['pretest_queue_threshold'] && (skipped_count_branch[settings['name']] >= settings['pretest_queue_threshold'])
              trusted_trigger_time, trigger_login = get_trusted_trigger_time(req, comments, Properties['settings'][settings['pretest_settings_key']])
              create_or_update_comment(req['number'], req['base']['repo']['name'], settings['pretest_comment'].gsub('[', '\[').gsub(']', '\]'), settings['pretest_comment'], comments) unless trusted_trigger_time
            end
          end
        end
      end
    end
  end

  #
  # A class to encapsulate the Jenkins API interaction
  #
  class JenkinsAPI
    def self.downstream_job_uri(branch, settings)
      job_name = branch_settings(branch, settings)['downstream_job_name']
      URI("#{Properties['jenkins_url']}job/#{job_name}/lastCompletedBuild/api/json")
    end

    def self.job_uri(branch, settings)
      job_name = branch_settings(branch, settings)['jenkins_job_name']
      URI("#{Properties['jenkins_url']}job/#{job_name}/lastCompletedBuild/api/json")
    end

    def self.get_session(branch, settings)
      proxy = Net::HTTP::Proxy(Properties['proxy_host'], Properties['proxy_port'])
      uri = nil
      if branch_settings(branch, settings)['downstream_job_name']
        uri = downstream_job_uri(branch, settings)
      else
        uri = job_uri(branch, settings)
      end
      session = proxy.new(uri.host, uri.port)
      session.use_ssl = true
      session.verify_mode = OpenSSL::SSL::VERIFY_NONE
      return session
    end

    def self.submit_jenkins_job(repo_to_pull_request, branch, extended_tests, settings)
      # First, get the next jenkins build number
      next_build_num = get_next_build(branch, settings)

      pull_id_params = "&BRANCH=#{branch}"
      first_valid_repo = nil
      repo_to_pull_request.each do |repo, pull_request|
        pull_id_param = settings['repo_to_pull_id_param'][repo]
        if pull_id_param
          pull_id_params += "&#{pull_id_param}=#{pull_request['number']}"
          first_valid_repo = repo unless first_valid_repo
        end
      end

      extended_tests_param = branch_settings(branch, settings)['extended_tests_param']
      if !extended_tests.empty? && extended_tests_param
        pull_id_params += "&#{extended_tests_param}=#{extended_tests.join(',')}"
      end

      if first_valid_repo
        addtl_jenkins_params = branch_settings(branch, settings)['addtl_jenkins_params']
        addtl_jenkins_params[Properties['repo_groups'][first_valid_repo]].each do |key, value|
          value.gsub!('*', branch) if value.is_a? String
          pull_id_params += "&#{key}=#{value}"
        end if addtl_jenkins_params
      end

      build_uri = URI(URI.escape(Properties['jenkins_url'] + 'job/' + branch_settings(branch, settings)['jenkins_job_name'] + "/buildWithParameters?token=#{branch_settings(branch, settings)['build_token']}#{pull_id_params}"))

      # Now submit the Jenkins job
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new build_uri.request_uri
        response = http.request request
        if (response.kind_of? Net::HTTPFound) || (response.kind_of? Net::HTTPCreated)
          $stderr.puts "  Successfully submitted job for pull request"

          # Block until Jenkins actually increments the build number (this isn't transactional)
          $stderr.puts "  Now waiting until build number increments..."
          while get_next_build(branch, settings) == next_build_num
            sleep 1
          end

          # Now you can safely return with the submission registered
          return Properties['jenkins_url'] + 'job/' + branch_settings(branch, settings)['jenkins_job_name'] + "/#{next_build_num}/"
        else
          raise "Jenkins job submission failed for pull request"
        end
      end
    end

    def self.is_project_stable?(branch, settings)
      if branch_settings(branch, settings)['downstream_job_name'] && branch_settings(branch, settings)['require_downstream_stability']
        get_session(branch, settings).start do |http|
          uri = downstream_job_uri(branch, settings)
          request = Net::HTTP::Get.new uri.request_uri
          response = http.request request
          if response.kind_of? Net::HTTPSuccess
            result = JSON.parse(response.body)["result"]
            return  result == "SUCCESS" || result == "UNSTABLE"
          else
            raise "Jenkins connection error"
          end
        end
      else
        return true
      end
    end

    def self.get_next_build(branch, settings, job_name=nil)
      job_name = job_name ? job_name : branch_settings(branch, settings)['jenkins_job_name']
      job_api_uri = URI("#{Properties['jenkins_url']}job/#{job_name}/api/json")
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new job_api_uri.request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          JSON.parse(response.body)["nextBuildNumber"].to_i
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.to_api_url build_url
      URI(build_url + "/api/json")
    end

    def self.is_previous_build_running?(branch, settings)
      build_num = get_next_build(branch, settings) - 1
      build_url = Properties['jenkins_url'] + 'job/' + branch_settings(branch, settings)['jenkins_job_name'] + "/#{build_num}/"
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["building"]
        elsif response.kind_of? Net::HTTPNotFound
          return false # maybe someone deleted the last build?
        else
          return true # assume it's running to avoid errors causing multiple builds to start
        end
      end
    end

    def self.is_build_running?(build_url, branch, settings)
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["building"]
        elsif response.kind_of? Net::HTTPNotFound
          return false
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.get_build_result(build_url, branch, settings)
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          job = JSON.parse(response.body)
          return job["result"]
        elsif response.kind_of? Net::HTTPNotFound
          return "NOTFOUND"
        else
          raise "Jenkins connection error"
        end
      end
    end
  end
end

#
#
# The main program script
#
#

# Create a new Hub client
@api_client ||= begin
  config_file = ENV['HUB_CONFIG'] || Properties['hub_config']
  file_store = GitHubAPI::FileStore.new File.expand_path(config_file)
  file_config = GitHubAPI::Configuration.new file_store
  GitHubAPI.new file_config, :app_url => Properties['jenkins_host']
end

if merge_pull_id
  @api_client.merge_pull_request(merge_pull_id, pull_id_repo, Properties['settings']['merge_test_settings'])
elsif mark_test_success_pull_id
  @api_client.mark_test_success(mark_test_success_pull_id, pull_id_repo, Properties['settings']['test_settings'])
elsif mark_testonlyextended_success_pull_id
  @api_client.mark_test_success(mark_testonlyextended_success_pull_id, pull_id_repo, Properties['settings']['testonlyextended_settings'])
elsif local_merge_pull_id
  @api_client.local_merge_pull_request(local_merge_pull_id, pull_id_repo)
elsif test_merge_pull_id
  @api_client.test_merge_pull_request(test_merge_pull_id, pull_id_repo, Properties['settings']['merge_test_settings'])
else
  # Process all the pull requests for testing
  $stderr.puts "Processing pull requests..."
  @api_client.process_pull_requests(merge_pretest_success)
  $stderr.puts "\nDone\n"
end
